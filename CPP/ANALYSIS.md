# 📊 Algorithm Analysis: test.cpp

제공된 C++ 코드를 분석한 결과는 다음과 같습니다.

---

### 1. 핵심 로직 흐름도 (Mermaid.js flowchart TD)

```mermaid
graph TD
    A[시작] --> B[정수 벡터 'numbers' 초기화: {1, 2, 3, 4, 5}];
    B --> C[람다 함수 'printNumber' 정의: n을 콘솔에 출력];
    C --> D[콘솔 출력: "Numbers: "];
    D --> E{for_each 루프 시작};
    E -- numbers.begin() 부터 numbers.end() 까지 --> F[각 요소를 'printNumber' 람다로 처리 (원본 숫자 출력)];
    F --> G[콘솔 출력: 개행];
    G --> H[콘솔 출력: "Doubled Numbers: "];
    H --> I{for_each 루프 시작};
    I -- numbers.begin() 부터 numbers.end() 까지 --> J[각 요소를 익명 람다 (n*2)로 처리 (두 배 값 출력)];
    J --> K[콘솔 출력: 개행];
    K --> L[종료];
```

---

### 2. 시간 복잡도와 공간 복잡도 설명

#### 시간 복잡도

이 코드의 시간 복잡도는 **O(N)** 입니다. 여기서 `N`은 `numbers` 벡터에 저장된 원소의 개수입니다 (현재 코드에서는 N=5).

*   `numbers` 벡터의 초기화는 `N`개의 원소를 복사하므로 O(N)의 시간이 소요됩니다.
*   첫 번째 `for_each` 루프는 벡터의 모든 `N`개 원소를 순회하며, 각 원소에 대해 상수 시간(O(1))의 연산(콘솔 출력)을 수행합니다. 따라서 이 루프는 O(N)의 시간 복잡도를 가집니다.
*   두 번째 `for_each` 루프도 마찬가지로 벡터의 모든 `N`개 원소를 순회하며, 각 원소에 대해 상수 시간(O(1))의 연산(곱셈 후 콘솔 출력)을 수행합니다. 따라서 이 루프 또한 O(N)의 시간 복잡도를 가집니다.
*   그 외 `cout` 문이나 람다 함수 정의는 상수 시간(O(1))에 해당합니다.

가장 지배적인 연산은 `for_each` 루프이므로, 전체 시간 복잡도는 **O(N)**이 됩니다.

#### 공간 복잡도

이 코드의 공간 복잡도는 **O(N)** 입니다. 여기서 `N`은 `numbers` 벡터에 저장된 원소의 개수입니다.

*   `numbers` 벡터는 `N`개의 정수를 저장하기 위해 O(N)의 메모리 공간을 필요로 합니다.
*   `printNumber` 람다 함수와 두 번째 `for_each`에 사용된 익명 람다 함수는 코드 자체로서 프로그램의 스택이나 코드 영역에 저장되며, 런타임에 동적으로 추가적인 O(N) 규모의 메모리를 할당하지 않습니다. 이는 상수 공간(O(1))에 해당합니다.
*   프로그램 실행에 필요한 기타 변수(예: 루프 카운터, 스트림 버퍼 등) 또한 상수 공간(O(1))만을 사용합니다.

따라서, 가장 큰 공간을 차지하는 요소는 `numbers` 벡터이므로, 전체 공간 복잡도는 **O(N)**이 됩니다.