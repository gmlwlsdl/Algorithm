```mermaid
flowchart TD
    A[시작] --> B{테스트 케이스 반복}
    B --> C[기본 입력 N K T M]
    C --> D[로그 테이블 초기화]
    D --> E{제출 기록 반복}
    E --> F[문제 최고 점수 업데이트]
    F --> G[제출 횟수 증가]
    G --> H[최신 제출 시간 기록]
    H --> I[전체 제출 시간 증가]
    I --> E
    E -- 모든 제출 처리 --> J[랭킹 계산 함수 호출]
    J --> K[사용자 리포트 초기화]
    K --> L{전체 사용자 순회}
    L --> M{각 사용자의 문제 로그 순회}
    M --> N[사용자 총점 합산]
    N --> O[사용자 총제출 합산]
    O --> P[사용자 마지막 제출 시간 갱신]
    P --> M
    M -- 문제 로그 완료 --> L
    L -- 모든 사용자 리포트 완료 --> Q[타겟 사용자 랭크 초기화]
    Q --> R{다른 사용자 순회}
    R --> S[타겟 사용자 제외]
    S --> T{점수 비교}
    T -- 점수 높음 --> U[랭크 증가]
    T -- 점수 같음 --> V{제출 횟수 비교}
    V -- 횟수 적음 --> U
    V -- 횟수 같음 --> W{마지막 제출 시간 비교}
    W -- 시간 빠름 --> U
    U --> R
    W -- 시간 같거나 느림 --> R
    V -- 횟수 많음 --> R
    T -- 점수 낮음 --> R
    R -- 모든 사용자 비교 완료 --> X[최종 랭크 출력]
    X --> B
    B -- 모든 테스트 완료 --> Y[종료]
```

### 2. 시간 복잡도와 공간 복잡도

*   **시간 복잡도**: `O(T * (N * K + M))`
    *   `T`: 테스트 케이스의 수
    *   `N`: 사용자의 수
    *   `K`: 문제의 수
    *   `M`: 전체 제출 기록의 수
    *   각 테스트 케이스 내에서, `M`개의 제출 기록을 처리하는 데 `O(M)` 시간이 소요됩니다.
    *   이후 `calc` 함수에서는 `N`명의 사용자에 대해 `K`개의 문제 로그를 순회하며 리포트를 계산하는 데 `O(N * K)` 시간이 소요됩니다.
    *   마지막으로 `N`명의 다른 사용자와 타겟 사용자의 순위를 비교하는 데 `O(N)` 시간이 소요됩니다.
    *   따라서 각 테스트 케이스당 총 시간 복잡도는 `O(M + N * K + N)`이며, 이는 `O(N * K + M)`으로 단순화될 수 있습니다.
    *   전체 시간 복잡도는 테스트 케이스 수 `T`를 곱하여 `O(T * (N * K + M))`이 됩니다.

*   **공간 복잡도**: `O(N * K)`
    *   `N`: 사용자의 수
    *   `K`: 문제의 수
    *   `table` 벡터는 `(N + 1) * (K + 1)` 크기의 `Log` 구조체를 저장하므로 `O(N * K)`의 공간을 사용합니다.
    *   `report` 벡터는 `(N + 1)` 크기의 `Report` 구조체를 저장하므로 `O(N)`의 공간을 사용합니다.
    *   지배적인 항은 `O(N * K)`이므로, 전체 공간 복잡도는 `O(N * K)`입니다.