```mermaid
flowchart TD
    A[시작] --> B[문자열 입력]
    B --> C{입력 문자열 "end" 여부}
    C -- 예 --> D[프로그램 종료]
    C -- 아니오 --> E[규칙 1 검사]
    E --> F{규칙 1 통과 여부}
    F -- 아니오 --> G[문자열 불수용]
    F -- 예 --> H[규칙 2 검사]
    H --> I{규칙 2 통과 여부}
    I -- 아니오 --> G
    I -- 예 --> J[규칙 3 검사]
    J --> K{규칙 3 통과 여부}
    K -- 아니오 --> G
    K -- 예 --> L[문자열 수용]
    G --> M[결과 출력]
    L --> M
    M --> B
```

### 시간 복잡도

제공된 C++ 코드는 각 입력 문자열(`s`)에 대해 세 가지 규칙(`rule1`, `rule2`, `rule3`)을 순차적으로 검사합니다.
*   `rule1(s)`: 문자열 `s`의 모든 문자를 순회하며 모음인지 확인합니다. `vowels` 벡터의 크기가 상수이므로, `find` 연산은 상수 시간으로 간주할 수 있습니다. 따라서 이 함수는 문자열 길이 `L`에 비례하는 `O(L)`의 시간을 소요합니다.
*   `rule2(s)`: 문자열 `s`의 모든 문자를 순회하며 모음 또는 자음의 연속 횟수를 확인합니다. 이 또한 문자열 길이 `L`에 비례하는 `O(L)`의 시간을 소요합니다.
*   `rule3(s)`: 문자열 `s`의 모든 문자를 순회하며 연속된 동일 문자를 확인합니다. 이 역시 문자열 길이 `L`에 비례하는 `O(L)`의 시간을 소요합니다.

`main` 함수에서는 "end" 문자열이 입력될 때까지 반복적으로 문자열을 입력받고 위 세 가지 규칙을 적용합니다. 만약 `N`개의 문자열이 입력되고, 각 문자열의 최대 길이가 `L_max`라면, 전체 시간 복잡도는 `O(N * L_max)`가 됩니다. (더 정확하게는, 모든 입력 문자열 길이의 합 `Sum(L_i)`에 비례하여 `O(Sum(L_i))`로 표현할 수 있습니다.)

결론적으로, 하나의 문자열을 처리하는 시간 복잡도는 **O(L)** 입니다.

### 공간 복잡도

*   `vowels`와 `consonants` 벡터는 전역 변수로 선언되어 있으며, 그 크기가 고정되어 있으므로 `O(1)`의 공간을 차지합니다.
*   `main` 함수 내에서 입력받는 문자열 `s`는 그 길이에 비례하는 공간을 필요로 합니다. 문자열의 길이가 `L`이라면 `O(L)`의 공간을 사용합니다.
*   각 규칙 함수 내부에서 사용되는 변수들(`v_cnt`, `c_cnt`, `vowel`, `consonant`, `c`, `flag`, `it` 등)은 상수 크기의 메모리만을 사용하므로 `O(1)`의 공간을 차지합니다.

따라서, 프로그램의 전체 공간 복잡도는 입력 문자열의 길이에 비례하여 **O(L)** 입니다. (최대 입력 문자열 길이를 기준으로 `O(L_max)`).