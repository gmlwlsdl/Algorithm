```mermaid
graph TD
    A[프로그램 시작] --> B[입출력 최적화];
    B --> C[N, M 입력];
    C --> D[2D 정수 배열 생성];
    D --> E[격자 데이터 입력];
    E --> F[최대 합계 초기화];
    F --> G{모든 비트마스크 순회 시작};
    G --> H[현재 총 합계 0];
    H --> I{각 행별 가로 숫자 처리 시작};
    I --> J[현재 가로 숫자 0];
    J --> K{각 열 순회 시작};
    K --> L{셀 비트마스크 상태 확인};
    L -- 비트 1 (가로) --> M[가로 숫자 누적];
    L -- 비트 0 (세로) --> N[가로 숫자 총 합계 추가, 초기화];
    M --> K;
    N --> K;
    K --> O{모든 열 처리 종료?};
    O -- 아니오 --> K;
    O -- 예 --> P[남은 가로 숫자 총 합계 추가];
    P --> Q{모든 행 처리 종료?};
    Q -- 아니오 --> I;
    Q -- 예 --> R{각 열별 세로 숫자 처리 시작};
    R --> S[현재 세로 숫자 0];
    S --> T{각 행 순회 시작};
    T --> U{셀 비트마스크 상태 확인};
    U -- 비트 0 (세로) --> V[세로 숫자 누적];
    U -- 비트 1 (가로) --> W[세로 숫자 총 합계 추가, 초기화];
    V --> T;
    W --> T;
    T --> X{모든 행 처리 종료?};
    X -- 아니오 --> T;
    X -- 예 --> Y[남은 세로 숫자 총 합계 추가];
    Y --> Z{모든 열 처리 종료?};
    Z -- 아니오 --> R;
    Z -- 예 --> AA[최대 합계 갱신];
    AA --> BB{모든 비트마스크 순회 종료?};
    BB -- 아니오 --> G;
    BB -- 예 --> CC[최대 합계 출력];
    CC --> DD[프로그램 종료];
```

### 2. 시간 복잡도와 공간 복잡도

*   **시간 복잡도**: `O(N*M * 2^(N*M))`
    *   이 알고리즘은 `N*M` 크기의 격자에 대해 모든 가능한 분할 방식(가로/세로)을 비트마스크를 이용하여 탐색합니다. 격자의 셀 개수를 `K = N*M`이라 할 때, `2^K`개의 모든 비트마스크를 순회합니다.
    *   각 비트마스크마다, 격자를 두 번 (`N*M` 가로 순회, `M*N` 세로 순회) 탐색하여 숫자를 형성하고 합계를 계산합니다. 이 과정은 `O(N*M)` 시간이 소요됩니다.
    *   따라서 전체 시간 복잡도는 `O(N*M * 2^(N*M))`이 됩니다.

*   **공간 복잡도**: `O(N*M)`
    *   입력 격자의 숫자들을 저장하기 위한 `v` 2차원 벡터가 `N*M` 크기의 정수 데이터를 저장합니다. 이는 `O(N*M)` 공간을 차지합니다.
    *   그 외의 변수들(예: `n, m, max_sum, total_sum, row_sum, col_sum` 등)은 격자 크기와 무관하게 상수 `O(1)` 공간을 사용합니다.
    *   따라서 전체 공간 복잡도는 `O(N*M)` 입니다.