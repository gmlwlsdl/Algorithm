```mermaid
graph TD
    A[시작] --> B[N K 값 입력];
    B --> C[벨트 내구도 초기화];
    C --> D[로봇 위치 초기화];
    D --> E[시뮬레이션 루프];
    E -- 반복 --> F[단계 카운트 증가];
    F --> G[벨트 및 로봇 전체 회전];
    G --> H[N-1 위치 로봇 하차];
    H --> I{내구도 0 개수 K 이상?};
    I -- 예 --> J[단계 결과 출력];
    I -- 아니오 --> K[로봇 이동 시도];
    K --> L[N-1 위치 로봇 하차];
    L --> M{내구도 0 개수 K 이상?};
    M -- 예 --> J;
    M -- 아니오 --> N[0 위치 로봇 승차 가능?];
    N -- 예 --> O[0 위치 내구도 감소];
    O --> P[0 위치 로봇 승차];
    P --> Q{내구도 0 개수 K 이상?};
    Q -- 예 --> J;
    Q -- 아니오 --> E;
    N -- 아니오 --> E;
    J --> R[종료];
```

### 시간 복잡도

*   **O(M * N)**
    *   `N`은 벨트 한 줄의 길이이며, 전체 벨트 길이는 `2N`입니다.
    *   `M`은 `a_cnt`가 `k`에 도달할 때까지의 시뮬레이션 단계 수입니다.
    *   각 시뮬레이션 단계에서는 `rotate` 함수와 `move` 함수가 호출됩니다.
        *   `rotate` 함수는 `2N`개 요소를 순회하며 회전시키므로 O(N) 시간이 소요됩니다.
        *   `move` 함수는 `N`개 요소를 순회하며 로봇 이동을 처리하므로 O(N) 시간이 소요됩니다.
    *   따라서 한 단계의 총 시간 복잡도는 O(N)이며, `M` 단계가 반복되므로 전체 시간 복잡도는 O(M * N)이 됩니다.

### 공간 복잡도

*   **O(N)**
    *   `a` 벡터는 벨트 내구도를 저장하며 `2N` 크기를 가집니다.
    *   `robots` 벡터는 로봇의 존재 여부를 저장하며 `2N` 크기를 가집니다.
    *   이 두 벡터가 프로그램이 사용하는 주된 메모리이며, `N`에 비례하는 공간을 사용합니다.
    *   따라서 공간 복잡도는 O(N)입니다.