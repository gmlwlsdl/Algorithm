1.  **알고리즘 핵심 로직 흐름 분석 및 시각화**

```mermaid
graph TD
    A[프로그램 시작] --> B[I/O 최적화]
    B --> C[행 열 연산횟수 입력]
    C --> D[원본 행렬 초기화]
    D --> E[원본 행렬 값 입력]
    E --> F{연산 반복}
    F --> |반복 시작| G[연산 종류 입력]
    G --> H[연산 함수 호출]
    H --> F
    F --> |반복 종료| I[결과 행렬 출력]
    I --> J[프로그램 종료]

    subgraph calc 함수
        K[calc 함수 시작] --> L[임시 행렬 생성]
        L --> M[원본 행렬 임시 복사]
        M --> N{연산 종류}
        N --> |op 1| O[상하 반전]
        N --> |op 2| P[좌우 반전]
        N --> |op 3| Q[시계 90도 회전]
        N --> |op 4| R[반시계 90도 회전]
        N --> |op 5| S[부분 배열 시계 이동]
        N --> |op 6| T[부분 배열 반시계 이동]

        Q --> Q1[새 임시 행렬 생성]
        Q1 --> Q2[회전 값 복사]
        Q2 --> Q3[원본 행렬 업데이트]
        Q3 --> Q4[행 열 크기 교환]
        Q4 --> U[calc 함수 종료]

        R --> R1[새 임시 행렬 생성]
        R1 --> R2[회전 값 복사]
        R2 --> R3[원본 행렬 업데이트]
        R3 --> R4[행 열 크기 교환]
        R4 --> U

        O --> U
        P --> U
        S --> U
        T --> U
    end

    H -- 호출 --> K
```

2.  **시간 복잡도와 공간 복잡도**

*   **시간 복잡도**: `O(R * N * M)`
    *   초기 `N x M` 크기의 행렬을 입력받는 데 `O(N*M)` 시간이 소요됩니다.
    *   총 `R`번의 연산(`calc` 함수 호출)이 수행됩니다.
    *   `calc` 함수 내부에서 행렬을 복사하거나 각 연산(상하 반전, 좌우 반전, 회전, 부분 배열 이동)을 수행할 때, 모든 요소에 접근하거나 새로운 행렬을 생성하여 복사하는 작업이 발생합니다. 이 모든 작업은 현재 행렬의 크기(`N*M`)에 비례합니다.
    *   따라서 한 번의 연산에 `O(N*M)` 시간이 소요되며, 총 `R`번 반복되므로 전체 시간 복잡도는 `O(R * N * M)`이 됩니다. `N`과 `M`은 연산 3, 4에 의해 서로 바뀔 수 있지만, `N*M`의 총 원소 개수는 동일합니다.

*   **공간 복잡도**: `O(N * M)`
    *   원본 행렬 `a`를 저장하는 데 `O(N*M)` 공간이 필요합니다.
    *   `calc` 함수 내에서 각 연산을 수행하기 위해 `temp` 행렬(`N x M`) 또는 `trans_temp` 행렬(`M x N`)과 같은 임시 행렬을 생성합니다. 이 임시 행렬들은 모두 `O(N*M)` 크기를 가집니다.
    *   따라서 추가적으로 필요한 최대 공간은 `O(N*M)`이며, 전체 공간 복잡도는 `O(N*M)`이 됩니다.