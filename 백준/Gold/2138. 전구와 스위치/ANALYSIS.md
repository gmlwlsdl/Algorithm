```mermaid
graph TD
    A[프로그램 시작] --> B[문자열 길이 N 입력];
    B --> C[현재 상태 문자열 입력];
    C --> D[목표 상태 문자열 입력];
    D --> E{0번 스위치 초기 토글 여부};

    E -- 토글 안 함 --> F[현재 상태 유지];
    F --> G[카운트 0 시작];
    G --> H[FIND 함수 호출 (0번 스위치 X)];
    H --> I[결과 1 저장];

    E -- 토글 함 --> J[현재 상태 복사본 생성];
    J --> K[복사본의 0번 스위치 토글];
    K --> L[카운트 1 시작];
    L --> M[FIND 함수 호출 (0번 스위치 O)];
    M --> N[결과 2 저장];

    I --> P[두 결과 비교];
    N --> P;
    P --> Q[최소 토글 횟수 출력];
    Q --> R[프로그램 종료];

    subgraph FIND 함수
        S[FIND 함수 시작] --> T[1부터 N-1까지 반복];
        T --> U{현재 문자열과 목표 문자열 일치};
        U -- 일치 --> V[현재 카운트 반환];
        U -- 불일치 --> W{i-1번째 문자 불일치};
        W -- 불일치 --> X[i번째 스위치 토글];
        X --> Y[카운트 증가];
        Y --> T;
        W -- 일치 --> T;
        V --> Z[FIND 함수 종료];
        T -- 반복 완료 --> AA{최종 일치 여부};
        AA -- 일치 --> BB[현재 카운트 반환];
        AA -- 불일치 --> CC[실패 값 -1 반환];
        BB --> Z;
        CC --> Z;
    end
```

### 시간 복잡도

*   **`toggle` 함수**: 스위치 인덱스에 따라 최대 3개의 문자를 변경합니다. 따라서 시간 복잡도는 O(1)입니다.
*   **`find` 함수**:
    *   `for` 루프는 `N-1`번 반복됩니다.
    *   루프 내부에서 `current == answer` 문자열 비교는 문자열 길이 `N`에 비례하는 O(N) 시간이 소요됩니다. 이 비교는 최악의 경우 매 반복마다 수행됩니다.
    *   `current[i-1] != answer[i-1]` 문자 비교 및 `toggle` 함수 호출은 각각 O(1) 시간이 소요됩니다.
    *   따라서 `find` 함수의 전체 시간 복잡도는 O(N * N) = O(N^2)입니다.
*   **`main` 함수**:
    *   `N` 입력 및 문자열 복사는 O(N)입니다.
    *   `toggle(exp, 0)` 호출은 O(1)입니다.
    *   `find` 함수를 두 번 호출하므로, 총 시간 복잡도는 2 * O(N^2) = O(N^2)입니다.

전체 알고리즘의 시간 복잡도는 **O(N^2)** 입니다.

### 공간 복잡도

*   `N` 변수는 O(1) 공간을 사용합니다.
*   `current`, `answer`, `exp` 세 개의 문자열은 각각 길이 `N`의 공간을 사용합니다. 따라서 O(N) 공간이 필요합니다.
*   그 외 다른 변수들은 O(1) 공간을 사용합니다.

전체 알고리즘의 공간 복잡도는 **O(N)** 입니다.