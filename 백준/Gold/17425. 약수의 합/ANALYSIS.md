```mermaid
flowchart TD
    A[시작] --> B{입력/출력 가속화 설정};
    B --> C[테스트 케이스 수 T 입력];
    C --> D[dp 벡터 선언 및 초기화 (크기 10^6+1, 값 0)];
    D --> E{i = 1 부터 10^6 까지 반복};
    E -- for i -- F{j = i 부터 10^6 까지 i의 배수로 반복};
    F -- for j -- G[dp[j] 에 i 더하기 (f(j)에 약수 i 반영)];
    G --> F;
    F --> H[dp[i] 에 dp[i-1] 더하기 (g(i) = g(i-1) + f(i) 계산)];
    H --> E;
    E --> I{T 번 반복};
    I -- while T-- -- J[정수 n 입력];
    J --> K[dp[n] 값 출력];
    K --> I;
    I --> L[종료];
```

### 시간 복잡도

*   **`O(N log N + T)`**
*   `N = 10^6`일 때, 약수의 합(f(x))과 그 누적합(g(x))을 미리 계산하는 과정이 핵심입니다.
    *   중첩된 `for` 루프(`for i`, `for j`)는 `i`가 약수가 되어 `i`의 모든 배수에 `i`를 더하는 방식으로 동작합니다. 이 부분의 시간 복잡도는 조화급수(harmonic series)의 합과 관련되어 `O(N log N)`이 됩니다 (예: `N/1 + N/2 + N/3 + ... + N/N = N * (1 + 1/2 + ... + 1/N) ≈ N log N`).
    *   `dp[i] += dp[i - 1]`를 통해 `f(i)` 값들을 `g(i)` 값(누적합)으로 변환하는 과정은 `N`번 반복되므로 `O(N)`입니다.
*   이후 `T`개의 각 질의(`while (t--)`)에 대해서는 미리 계산된 `dp` 배열에서 값을 찾는 `O(1)` 연산만 수행하므로, 총 `O(T)`의 시간이 소요됩니다.
*   따라서 전체 시간 복잡도는 `O(N log N + T)`가 되며, `N log N`이 지배적입니다.

### 공간 복잡도

*   **`O(N)`**
*   주요 공간 사용은 `long long` 타입의 `dp` 벡터입니다. 이 벡터는 `10^6 + 1` 크기로 선언되어 `N`까지의 모든 `g(x)` 값을 저장합니다. 따라서 `O(N)`의 공간 복잡도를 가집니다.
*   다른 변수들(`t`, `n`, 루프 변수 `i`, `j` 등)은 상수 공간을 사용합니다.